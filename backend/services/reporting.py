"""
Report generation
"""
#Heavily assitance from AI 
import io
from datetime import datetime, timezone
from backend.services.statistics import MaintenanceStatistics
from backend.models.machine import Machine, Subsystem, Component
from backend.models.work_order import WorkOrder
from backend.models.maintenance_log import MaintenanceLog
from backend.models.user import User
from backend.models.failure import Failure
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
from sqlalchemy import func
from backend.database import db
import os

class ReportGenerator:
    @staticmethod
    def generate_pdf_report(report_type, machine_id=None, subsystem_id=None, component_id=None, start_date=None, end_date=None, generated_by=None):
        """Generate a PDF report based on type and filters"""
        buffer = io.BytesIO()
        
        # Create PDF document
        doc = SimpleDocTemplate(buffer, pagesize=letter)
        styles = getSampleStyleSheet()
        elements = []
        
        # Add report title
        if report_type == 'work_orders':
            title = "Work Orders Report"
        elif report_type == 'failures':
            title = "Failures Report"
        elif report_type == 'maintenance':
            title = "Maintenance Activities Report"
        elif report_type == 'statistics':
            title = "Maintenance Statistics Report"
        else:
            title = f"{report_type.capitalize()} Report"
                
        elements.append(Paragraph(title, styles['Title']))
        elements.append(Spacer(1, 12))
        
        # Add report metadata
        now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M")
        metadata = [
            f"Generated on: {now}",
            f"Generated by: {generated_by or 'System'}"
        ]
        
        # Add entity info based on what's provided
        if component_id:
            component = Component.query.get(component_id)
            if component:
                metadata.append(f"Component: {component.name} ({component.technical_id})")
                
                # Add parent info
                subsystem = Subsystem.query.get(component.subsystem_id)
                if subsystem:
                    metadata.append(f"Subsystem: {subsystem.name} ({subsystem.technical_id})")
                    
                metadata.append(f"Machine: {component.machine.name}")
        elif subsystem_id:
            subsystem = Subsystem.query.get(subsystem_id)
            if subsystem:
                metadata.append(f"Subsystem: {subsystem.name} ({subsystem.technical_id})")
                metadata.append(f"Machine: {subsystem.machine.name}")
        elif machine_id:
            machine = Machine.query.get(machine_id)
            if machine:
                metadata.append(f"Machine: {machine.name}")
                    
        if start_date and end_date:
            metadata.append(f"Period: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}")
        elif start_date:
            metadata.append(f"From: {start_date.strftime('%Y-%m-%d')}")
        elif end_date:
            metadata.append(f"To: {end_date.strftime('%Y-%m-%d')}")
                
        for meta in metadata:
            elements.append(Paragraph(meta, styles['Normal']))
                
        elements.append(Spacer(1, 24))
        
        # Add report content based on type
        if report_type == 'work_orders':
            ReportGenerator._add_work_orders_content(elements, styles, machine_id, subsystem_id, component_id, start_date, end_date)
        elif report_type == 'failures':
            ReportGenerator._add_failures_content(elements, styles, machine_id, subsystem_id, component_id, start_date, end_date)
        elif report_type == 'statistics':
            ReportGenerator._add_statistics_content(elements, styles, machine_id, subsystem_id, component_id, start_date, end_date)
        elif report_type == 'maintenance':
            ReportGenerator._add_maintenance_content(elements, styles, machine_id, subsystem_id, component_id, start_date, end_date)
        
        # Build the PDF
        doc.build(elements)
        buffer.seek(0)
        return buffer

    @staticmethod
    def _add_work_orders_content(elements, styles, machine_id, start_date, end_date):
        """Add work orders report content"""
        elements.append(Paragraph("Work Orders Summary", styles['Heading2']))
        elements.append(Spacer(1, 12))
        
        # Get work order statistics
        work_order_stats = MaintenanceStatistics.get_work_order_statistics(machine_id, start_date, end_date)
        
        # Create summary table
        summary_data = [
            ['Machine', 'Total', 'Open', 'In Progress', 'Completed', 'Preventive', 'Corrective']
        ]
        
        total_orders = 0
        total_open = 0
        total_in_progress = 0
        total_completed = 0
        total_preventive = 0
        total_corrective = 0
        
        for stat in work_order_stats:
            row = [
                stat['machine_name'],
                stat['total_work_orders'],
                stat['by_status'].get('open', 0),
                stat['by_status'].get('in_progress', 0),
                stat['by_status'].get('completed', 0),
                stat['by_type'].get('preventive', 0),
                stat['by_type'].get('corrective', 0)
            ]
            summary_data.append(row)
            
            total_orders += stat['total_work_orders']
            total_open += stat['by_status'].get('open', 0)
            total_in_progress += stat['by_status'].get('in_progress', 0)
            total_completed += stat['by_status'].get('completed', 0)
            total_preventive += stat['by_type'].get('preventive', 0)
            total_corrective += stat['by_type'].get('corrective', 0)
        
        # Add totals row
        summary_data.append([
            'TOTAL',
            total_orders,
            total_open,
            total_in_progress,
            total_completed,
            total_preventive,
            total_corrective
        ])
        
        # Create table
        summary_table = Table(summary_data)
        summary_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, -1), (-1, -1), colors.lightgrey),
            ('FONTNAME', (0, -1), (-1, -1), 'Helvetica-Bold'),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('ALIGN', (1, 1), (-1, -1), 'CENTER'),
        ]))
        
        elements.append(summary_table)
        elements.append(Spacer(1, 24))
        
        # Add detailed work orders if not too many, Might be relevant to only add important ones
        if total_orders <= 50:  # Limit to 50 to avoid huge PDFs
            elements.append(Paragraph("Work Order Details", styles['Heading2']))
            elements.append(Spacer(1, 12))
            
            # Query work orders
            query = WorkOrder.query
            
            if machine_id:
                query = query.filter(WorkOrder.machine_id == machine_id)
                
            if start_date:
                query = query.filter(WorkOrder.created_at >= start_date)
                
            if end_date:
                query = query.filter(WorkOrder.created_at <= end_date)
                
            work_orders = query.order_by(WorkOrder.due_date).all()
            
            for work_order in work_orders:
                machine = Machine.query.get(work_order.machine_id)
                
                # Work order details paragraph
                wo_title = f"WO#{work_order.id}: {work_order.title} ({work_order.status.upper()})"
                elements.append(Paragraph(wo_title, styles['Heading3']))
                
                details = [
                    f"Machine: {machine.name}",
                    f"Priority: {work_order.priority}",
                    f"Type: {work_order.type}",
                    f"Due Date: {work_order.due_date.strftime('%Y-%m-%d')}",
                    f"Description: {work_order.description}"
                ]
                
                for detail in details:
                    elements.append(Paragraph(detail, styles['Normal']))
                    
                elements.append(Spacer(1, 12))
        else:
            elements.append(Paragraph("Note: There are too many work orders to display details. Please use filters to narrow down the results.", styles['Italic']))
            
    @staticmethod
    def _add_failures_content(elements, styles, machine_id=None, subsystem_id=None, component_id=None, start_date=None, end_date=None):
        """Add failures report content"""
        elements.append(Paragraph("Failures Summary", styles['Heading2']))
        elements.append(Spacer(1, 12))
        
        # Get failure statistics using the unified function
        failure_rates = MaintenanceStatistics.get_failure_rates(machine_id, subsystem_id, component_id, start_date, end_date)
        
        if not failure_rates:
            elements.append(Paragraph("No failure data available for the selected period.", styles['Normal']))
            return
        
        # Determine what level of data we're working with based on the first result
        level = failure_rates[0].get('level', 'machine')
        
        # Get the denominator from the first result to use in column headers
        denominator = failure_rates[0].get('denominator', 100)
        
        # Create appropriate table headers based on level
        if level == 'component':
            summary_data = [
                ['Component', 'Technical ID', 'Subsystem', 'Machine', 'Failures', 'Hours', f'Rate (per {denominator}h)']
            ]
        elif level == 'subsystem':
            summary_data = [
                ['Subsystem', 'Technical ID', 'Machine', 'Failures', 'Hours', f'Rate (per {denominator}h)']
            ]
        else:  # machine level
            summary_data = [
                ['Machine', 'Technical ID', 'Failures', 'Hours', f'Rate (per {denominator}h)']
            ]
        
        # Add data rows based on level
        total_failures = 0
        total_hours = 0
        
        for rate in failure_rates:
            if level == 'component':
                row = [
                    rate['name'],
                    rate['technical_id'],
                    rate.get('subsystem_name', ''),
                    rate.get('machine_name', ''),
                    rate['failure_count'],
                    rate['operation_hours'],
                    rate['failure_rate_per_x_hours']  # Use the new field name
                ]
            elif level == 'subsystem':
                row = [
                    rate['name'],
                    rate['technical_id'],
                    rate.get('machine_name', ''),
                    rate['failure_count'],
                    rate['operation_hours'],
                    rate['failure_rate_per_x_hours']  # Use the new field name
                ]
            else:  # machine level
                row = [
                    rate['name'],
                    rate['technical_id'],
                    rate['failure_count'],
                    rate['operation_hours'],
                    rate['failure_rate_per_x_hours']  # Use the new field name
                ]
            
            summary_data.append(row)
            total_failures += rate['failure_count']
            total_hours += rate['operation_hours']
        
        # Add totals row with the correct calculation
        total_rate = round((total_failures / total_hours * denominator) if total_hours > 0 else 0, 2)
        
        if level == 'component':
            summary_data.append([
                'TOTAL', '', '', '',
                total_failures,
                total_hours,
                total_rate
            ])
        elif level == 'subsystem':
            summary_data.append([
                'TOTAL', '', '',
                total_failures,
                total_hours,
                total_rate
            ])
        else:  # machine level
            summary_data.append([
                'TOTAL', '',
                total_failures,
                total_hours,
                total_rate
            ])
            
        # Create table
        summary_table = Table(summary_data)
        
        # Apply styles (row colors, alignment, etc.)
        header_count = len(summary_data[0])
        summary_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, -1), (-1, -1), colors.lightgrey),
            ('FONTNAME', (0, -1), (-1, -1), 'Helvetica-Bold'),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('ALIGN', (header_count-3, 1), (-1, -1), 'CENTER'),  # Center-align numeric columns
        ]))
        
        elements.append(summary_table)
        elements.append(Spacer(1, 24))
                
    @staticmethod
    def _add_statistics_content(elements, styles, machine_id, start_date, end_date):
        """Add maintenance statistics content"""
        # MTBF and MTTR statistics
        elements.append(Paragraph("Mean Time Between Failures & Mean Time To Repair", styles['Heading2']))
        elements.append(Spacer(1, 12))
        
        mtbf_mttr = MaintenanceStatistics.get_mtbf_mttr(machine_id, start_date, end_date)
        
        if mtbf_mttr:
            # Create summary table
            mtbf_data = [
                ['Machine', 'Failures', 'MTBF (hours)', 'MTTR (hours)']
            ]
            
            for stat in mtbf_mttr:
                row = [
                    stat['machine_name'],
                    stat['failure_count'],
                    stat['mtbf_hours'],
                    stat['mttr_hours']
                ]
                mtbf_data.append(row)
            
            # Create table
            mtbf_table = Table(mtbf_data)
            mtbf_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('ALIGN', (1, 1), (-1, -1), 'CENTER'),
            ]))
            
            elements.append(mtbf_table)
        else:
            elements.append(Paragraph("No MTBF/MTTR data available for the selected period.", styles['Normal']))
            
        elements.append(Spacer(1, 24))
        
        # Uptime statistics
        elements.append(Paragraph("Uptime Statistics", styles['Heading2']))
        elements.append(Spacer(1, 12))
        
        uptime_stats = MaintenanceStatistics.get_uptime_statistics(machine_id, start_date, end_date)
        
        if uptime_stats:
            # Create summary table
            uptime_data = [
                ['Machine', 'Period (hours)', 'Uptime (hours)', 'Downtime (hours)', 'Uptime %']
            ]
            
            for stat in uptime_stats:
                row = [
                    stat['machine_name'],
                    stat['period_hours'],
                    stat['uptime_hours'],
                    stat['downtime_hours'],
                    f"{stat['uptime_percentage']}%"
                ]
                uptime_data.append(row)
            
            # Create table
            uptime_table = Table(uptime_data)
            uptime_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('ALIGN', (1, 1), (-1, -1), 'CENTER'),
            ]))
            
            elements.append(uptime_table)
        else:
            elements.append(Paragraph("No uptime data available for the selected period.", styles['Normal']))
        
        elements.append(Spacer(1, 24))
        
        # Work Order Distribution
        elements.append(Paragraph("Work Order Distribution", styles['Heading2']))
        elements.append(Spacer(1, 12))
        
        work_order_stats = MaintenanceStatistics.get_work_order_statistics(machine_id, start_date, end_date)
        
        if work_order_stats:
            # Create a table showing preventive vs corrective work
            preventive_vs_corrective_data = [
                ['Machine', 'Preventive', 'Predictive', 'Corrective', 'Total']
            ]
            
            for stat in work_order_stats:
                preventive = stat['by_type'].get('preventive', 0)
                predictive = stat['by_type'].get('predictive', 0)
                corrective = stat['by_type'].get('corrective', 0)
                total = stat['total_work_orders']
                
                row = [
                    stat['machine_name'],
                    preventive,
                    predictive,
                    corrective,
                    total
                ]
                preventive_vs_corrective_data.append(row)
            
            # Create table
            wo_dist_table = Table(preventive_vs_corrective_data)
            wo_dist_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('ALIGN', (1, 1), (-1, -1), 'CENTER'),
            ]))
            
            elements.append(wo_dist_table)
        else:
            elements.append(Paragraph("No work order distribution data available for the selected period.", styles['Normal']))

    @staticmethod
    def _add_maintenance_content(elements, styles, machine_id, start_date, end_date):
        """Add maintenance activities content"""
        elements.append(Paragraph("Maintenance Activities Log", styles['Heading2']))
        elements.append(Spacer(1, 12))
        
        # Query maintenance logs
        query = db.session.query(
            MaintenanceLog,
            Machine.name.label('machine_name'),
            User.username.label('performed_by_name')
        ).join(
            Machine, MaintenanceLog.machine_id == Machine.id
        ).join(
            User, MaintenanceLog.performed_by == User.id
        )
        
        if machine_id:
            query = query.filter(MaintenanceLog.machine_id == machine_id)
            
        if start_date:
            query = query.filter(MaintenanceLog.timestamp >= start_date)
            
        if end_date:
            query = query.filter(MaintenanceLog.timestamp <= end_date)
            
        # Order by timestamp descending (newest first)
        query = query.order_by(MaintenanceLog.timestamp.desc())
        
        logs = query.all()
        
        if logs:
            # Create maintenance log table
            log_data = [
                ['Date', 'Machine', 'Performed By', 'Type', 'Description', 'Deviation']
            ]
            
            for log_entry in logs:
                log = log_entry[0]
                
                # Format has_deviation as Yes/No
                has_deviation = "Yes" if log.has_deviation else "No"
                
                # Truncate description if too long
                description = log.description
                if len(description) > 50:
                    description = description[:47] + "..."
                
                row = [
                    log.timestamp.strftime('%Y-%m-%d'),
                    log_entry.machine_name,
                    log_entry.performed_by_name,
                    log.maintenance_type or "N/A",
                    description,
                    has_deviation
                ]
                log_data.append(row)
            
            # Create table
            log_table = Table(log_data)
            log_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ]))
            
            elements.append(log_table)
            
            # Maintenance type distribution
            elements.append(Spacer(1, 24))
            elements.append(Paragraph("Maintenance Type Distribution", styles['Heading2']))
            elements.append(Spacer(1, 12))
            
            # Count maintenance by type
            maintenance_types = {}
            
            for log_entry in logs:
                log = log_entry[0]
                maint_type = log.maintenance_type or "Unspecified"
                
                if maint_type not in maintenance_types:
                    maintenance_types[maint_type] = 0
                    
                maintenance_types[maint_type] += 1
                
            # Create type distribution table
            type_dist_data = [
                ['Maintenance Type', 'Count', 'Percentage']
            ]
            
            total_count = len(logs)
            
            for maint_type, count in sorted(maintenance_types.items(), key=lambda x: x[1], reverse=True):
                percentage = (count / total_count * 100) if total_count > 0 else 0
                row = [
                    maint_type,
                    count,
                    f"{percentage:.1f}%"
                ]
                type_dist_data.append(row)
            
            # Create table
            type_dist_table = Table(type_dist_data)
            type_dist_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('ALIGN', (1, 1), (-1, -1), 'CENTER'),
            ]))
            
            elements.append(type_dist_table)
        else:
            elements.append(Paragraph("No maintenance logs available for the selected period.", styles['Normal']))

    @staticmethod
    def generate_excel_report(report_type, machine_id=None, start_date=None, end_date=None):
        """Generate Excel report using pandas"""
        import pandas as pd
        
        # This will be implemented in the export_service.py file
        # See earlier implementation of ExportService
        pass